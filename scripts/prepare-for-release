#!/bin/bash

# Script to:
## 1) create and checkout a new branch with the latest tag name
## 2) update AEMM and Helm chart versions
## 3) commit release prep changes to new branch
## 4) create a PR from the new branch to upstream/master

## The following files are updated in step (2):
### - helm charts' Chart.yaml
### - helm charts' values.yaml
### - helm charts' README
### - README.md

# Prerequisites:
## 1) git and gh cli (make sure to use gh cli before running this script as authentication is required)
## 2) local tag creation is separated from this script and a new tag must be created before this script is run. This is automated when this script is run via make targets.  
## 3) remote branches tracking is setup for origin and upstream

# NOTE: only the files updated by this script is included in the commit / PR i.e. release version updates in $FILES
# This script is NOT intended to be combined with other unmerged local changes

set -uo pipefail

REPO_ROOT_PATH="$( cd "$(dirname "$0")"; cd ../; pwd -P )"
MAKEFILE_PATH=$REPO_ROOT_PATH/Makefile
LATEST_VERSION=$(make -s -f $MAKEFILE_PATH latest-release-tag | cut -b 2- )
PREVIOUS_VERSION=$(make -s -f $MAKEFILE_PATH previous-release-tag | cut -b 2- )
# REPO_NAME=$(make -s -f $MAKEFILE_PATH repo-full-name)
REPO_NAME="pdk27/amazon-ec2-metadata-mock-1"

# Files to update
REPO_README=$REPO_ROOT_PATH/README.md
CHART=$REPO_ROOT_PATH/helm/amazon-ec2-metadata-mock/Chart.yaml
CHART_VALUES=$REPO_ROOT_PATH/helm/amazon-ec2-metadata-mock/values.yaml
CHART_README=$REPO_ROOT_PATH/helm/amazon-ec2-metadata-mock/README.md
FILES=($REPO_README  $CHART  $CHART_README  $CHART_VALUES)
FILES_CHANGED=()

LATEST_TAG="v$LATEST_VERSION"
NEW_BRANCH_NAME="pr/$LATEST_TAG-release"
COMMIT_MESSAGE="ü•ëü§ñ $LATEST_TAG release prep [Skip Helm E2E Tests] ü§ñü•ë"

PR_HEAD=$NEW_BRANCH_NAME  # source
PR_BASE=master  # target
PR_BODY="ü•ëü§ñ Auto-generated PR for $LATEST_TAG release. Updating release versions in repo."

create_release_branch() {
    # create a new branch with tag name and add remote upstream
    git checkout -b $NEW_BRANCH_NAME
    echo -e "‚úÖ Created new release branch $NEW_BRANCH_NAME\n\n"
}

update_versions() {
    # update release version for release prep
    echo -e "ü•ë Attempting to update AEMM release version and Helm chart version in preparation for a new release.\n   Previous version: $PREVIOUS_VERSION ---> Latest version: $LATEST_VERSION"

    for f in ${FILES[@]}; do
        has_incorrect_version=$(cat $f | grep $PREVIOUS_VERSION)
        if [[ ! -z  $has_incorrect_version ]]; then
            sed -i '' "s/$PREVIOUS_VERSION/$LATEST_VERSION/g" $f
            FILES_CHANGED+=($f)
        fi
    done

    if [[ ! -z $FILES_CHANGED ]]; then
        echo -e "‚úÖ‚úÖ Updated versions from $PREVIOUS_VERSION to $LATEST_VERSION in files: \n$(echo "${FILES_CHANGED[@]}" | tr ' ' '\n')"
        echo -e "To see changes, run \`git diff HEAD^ HEAD\`"
    else
        echo -e "\n‚úÖ‚úÖ All files already use the latest release version $LATEST_VERSION. No files were modified."
    fi
    echo
}

commit_changes() {
    # make release prep changes and commit to new branch with prefix [skip ci]
    echo -e "\nü•ë Adding and committing release version changes."
    git add "${FILES_CHANGED[@]}"
    git commit -m"$COMMIT_MESSAGE"
    echo -e "‚úÖ‚úÖ‚úÖ Committed release prep changes to new branch $NEW_BRANCH_NAME with commit message '$COMMIT_MESSAGE'\n\n"
}

add_label_to_pr() {
    curl -X PATCH \
        -H "Authorization: token $GITHUB_TOKEN" \
        --write-out %{http_code} \
        -d '{"labels": ["auto-generated release-prep"]}' \
        https://api.github.com/repos/${REPO_NAME}/issues/$1
}

create_pr() {
    # verify that origin and upstream are set
    remote_branches=$(git remote)
    expected_remote_branches=( "origin" "upstream")
    if [[ ${remote_branches[*]} != ${expected_remote_branches[*]} ]]; then
        echo -e "‚ùå Expected the following remote branches to be tracked: $expected_remote_branches. Set it up before running this script again."
    fi

    # create a PR from new branch to origin/master
    git push -u origin $NEW_BRANCH_NAME
    response=$(curl -X POST \
        -H "Authorization: token $GITHUB_TOKEN" \
        --write-out %{http_code} \
        -d '{"title": "${COMMIT_MESSAGE}", "base": "${PR_BASE}", "head": "${PR_HEAD}", "body": "${PR_BODY}"}' \
        https://api.github.com/repos/${REPO_NAME}/pulls)

    response_code=$(echo $response | sed 's/\(.*\)}//')
    response_content=$(echo $response | sed "s/$response_code//")

    # HTTP success code expected - 201 Created
    if [[ $response_code -eq 201 ]]; then
        pr_link=$(echo $response_content | jq '.html_url')
        pr_issue_number=$(echo $response | jq '.issue_url')
        add_label_to_pr $pr_issue_number
        echo -e "‚úÖ‚úÖ‚úÖ‚úÖ Created $LATEST_TAG release prep PR $pr_link\n"
    else
        echo -e "‚ùå PR creation failed with response code $response_code and message \n$response_content. Rolling back.‚ùå"
        rollback
        exit 1
    fi
}

# rollback partial changes so that this script can be run atomically
rollback() {
    # checkout of current branch to master
    git checkout master

    # delete local and remote release branch
    git branch -d $NEW_BRANCH_NAME
    git push origin --delete $NEW_BRANCH_NAME
}

handle_errors() {
    # error handling
    if [ $1 != "0" ]; then
        FAILED_COMMAND=${@:2}
        echo -e "\n‚ùå Error occurred while running command ${FAILED_COMMAND} ‚ùå"
        exit 1
    fi
    exit $1
}

main() {
    trap 'handle_errors $? $BASH_COMMAND' EXIT

    create_release_branch
    update_versions
    commit_changes
    create_pr
}

main $@